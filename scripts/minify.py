#!/usr/bin/env python3.6
# -*- coding: utf-8 -*-
import argparse
import logging
import os
import shutil, tempfile
import re
from enum import Enum
from subprocess import Popen, PIPE

# Dependencies:
#   - p8tool (from picotool repo) must be in PATH
#   - luamin must have been installed locally with `npm update` or `pico-boots/setup.sh`

# This script minifies the __lua__ section of a cartridge {game}.p8:
# 1. It uses p8tool listlua A.p8 to quickly extract the __lua__ code into {game}.lua
# 2. Convert remaining bits of pico8 lua (generated by p8tool) into clean lua
# 3. It applies luamin to {game}.lua and outputs to {game}_min.lua
# 4. It reads the header (before __lua__) of {game}.p8 and copies it into {game}_min.p8
# 5. It appends {game}_min.lua's content to {game}_min.p8
# 6. It finishes reading {game}.p8's remaining sections and appends them into {game}_min.p8
# 7. It replaces {game}.p8 with {game}_min.p8

MINIFY_SCRIPT_RELATIVE_PATH = "npm/node_modules/.bin/luamin"

script_dir_path = os.path.dirname(os.path.realpath(__file__))
minify_script_path = os.path.join(script_dir_path, MINIFY_SCRIPT_RELATIVE_PATH)

LUA_HEADER = b"__lua__\n"
# Note that this pattern captures 1. condition 2. result of a "one-line if" if it is,
# but that it also matches a normal if-then, requiring a check before using the pattern.
# This pattern may not be exhaustive as the user may put extra brackets but still use if-then
# if issues arive, add a negative check to make sure the line doesn't end with "then" or even "\"
# In practice, a developer using pico-boots should write clean lua, and only picotool
# should add a short if statement for the require bridging code.
PICO8_ONE_LINE_IF_PATTERN = re.compile(r"if \(([^)]*)\) (.*)")


class Phase(Enum):
    CARTRIDGE_HEADER = 1  # copying header, from "pico-8 cartridge..." to "__lua__"
    LUA_SECTION      = 2  # found "__lua__", still copy the 2 author/version comment lines then appending minified lua all at once
    LUA_CATCHUP      = 3  # skipping the unused unminified lua until we reach the other sections
    OTHER_SECTIONS   = 4  # copying the last sections


def minify_lua_in_p8(cartridge_filepath, minify_level):
    """
    Minifies the __lua__ section of a p8 cartridge, using luamin.

    """
    logging.debug(f"Minifying lua in cartridge {cartridge_filepath}...")

    basepath, ext = os.path.splitext(cartridge_filepath)

    # verify extension
    if ext != ".p8":
        raise Exception(f"Cartridge filepath '{cartridge_filepath}' does not end with '.p8'")

    min_cartridge_filepath = f"{basepath}_min{ext}"
    lua_filepath = f"{basepath}.lua"
    min_lua_filepath = f"{basepath}_min.lua"

    # Step 1: extract lua code into separate file
    with open(lua_filepath, 'w') as lua_file:
        extract_lua(cartridge_filepath, lua_file)

    # Step 2-3: minify lua file
    minify_lua_file(lua_filepath, min_lua_filepath, minify_level)

    # Step 4-6: inject minified lua code into target cartridge
    phase = Phase.CARTRIDGE_HEADER
    with open(cartridge_filepath, 'r') as source_file,     \
         open(min_cartridge_filepath, 'w') as target_file, \
         open(min_lua_filepath, 'r') as min_lua_file:
        inject_minified_lua_in_p8(source_file, target_file, min_lua_file)

    # Step 7: replace original p8 with minified p8, clean up intermediate files
    os.remove(cartridge_filepath)  # generally move overwrites it anyway, but just in case
    os.remove(lua_filepath)
    os.remove(min_lua_filepath)
    shutil.move(min_cartridge_filepath, cartridge_filepath)


def extract_lua(source_filepath, lua_file):
    """
    Extract lua from .p8 cartridge at source_filepath (string) to lua_file (file descriptor: write)

    """
    # p8tool listrawlua bug (https://github.com/dansanderson/picotool/issues/59)
    #   was fixed, so we prefer it to listlua as it is almost instant compared to listlua
    #   which takes ~1s to parse the game .p8

    # However, note that it outputs an extra newline after *each* line, which will be stripped during minification most of the time
    # but will stay in [[multi-line strings]]. So we *must* skip every other line (preserve odd lines) using e.g. awk
    # https://superuser.com/questions/101756/show-only-odd-lines-with-cat

    # Usually a check_call(stdout=min_lua_file) (and no stderr) is enough,
    #  as it throws CalledProcessError on error by itself, but in this case, due to output stream sync issues
    #  (luamin error shown before __main__ print at the bottom of this script),
    #  we prefer Popen + PIPE + communicate() + check stderrdata
    # For awk we just use a '|' in shell mode, a bit easier than calling Popen a second time with stdin = stdout of first process
    (_stdoutdata, stderrdata) = Popen([f"p8tool listrawlua \"{source_filepath}\" | awk 'NR % 2 == 1'"], shell=True, stdout=lua_file, stderr=PIPE).communicate()
    if stderrdata:
        raise Exception(f"p8tool listrawlua failed with:\n\n{stderrdata.decode()}")


def minify_lua_file(lua_filepath, min_lua_filepath, minify_level):
    logging.debug(f"Minifying lua in file {lua_filepath} into {min_lua_filepath}...")

    _basepath, ext = os.path.splitext(lua_filepath)

    # verify extension
    if ext != ".lua":
        raise Exception(f"Cartridge filepath '{lua_filepath}' does not end with '.lua'")

    # Step 2: clean lua code in this file in-place
    with open(lua_filepath, 'r') as lua_file:
        # create temporary file object (we still need to open it with mode to get file descriptor)
        temp_file_object, temp_filepath = tempfile.mkstemp()
        original_char_count = sum(len(line) for line in lua_file)
        logging.debug(f"Original lua code has {original_char_count} characters")
        # we wrote to lua_file and are now at the end, so rewind
        lua_file.seek(0)
        clean_lua(lua_file, os.fdopen(temp_file_object, 'w'))

    # replace original lua code with clean code
    os.remove(lua_filepath)
    shutil.move(temp_filepath, lua_filepath)

    # Step 3: apply luamin to generate minified code in a different file
    with open(min_lua_filepath, 'w+') as min_lua_file:
        minify_lua(lua_filepath, min_lua_file, minify_level)
        min_lua_file.seek(0)
        min_char_count = sum(len(line) for line in min_lua_file)
        logging.debug(f"Minified lua code to {min_char_count} characters")
        if min_char_count > 65536:
            raise Exception(f"Maximum character count of 65536 has been exceeded ({min_char_count} characters after minification), cartridge would be truncated in PICO-8, so exit with failure.")


def clean_lua(lua_file, clean_lua_file):
    """
    Convert PICO-8 specific lines from to lua_file (file descriptor: read)
    to native Lua in clean_lua_file (file descriptor: write)

    """
    for line in lua_file:
        # we simplify things a lot thanks to our assumptions on the generated code
        # we know that the only pico8 one-line if will be generated for the require function
        #   and have the pattern "if (condition) [result]" without "then",
        #   and there are no edge cases like embedded conditions or continuing line with "\"
        if line.startswith("if (") and "then" not in line:
            # convert to "if [condition] then [result] end"
            clean_lua_file.write(PICO8_ONE_LINE_IF_PATTERN.sub("if \\1 then \\2 end", line))
        else:
            clean_lua_file.write(line)


def minify_lua(clean_lua_filepath, min_lua_file, minify_level=1):
    """
    Minify lua from clean_lua_filepath (string)
    and send output to min_lua_file (file descriptor: write)

    Use option:
      -f to pass filepath
      -n to use newline separator (for easier debug)

    Also use options depending on minify level:
      -mk to minify member names and table key strings (should be done together as some members will be defined
        directly inside table, others defined and accessed with dot syntax)
      -G to minify assigned global variable names
      -F to minify globally declared function names

    """
    options = "-fn"
    if minify_level >= 2:
        options += "mk"
    if minify_level >= 3:
        options += "GF"

    # see extract_lua for reason to use Popen
    (_stdoutdata, stderrdata) = Popen([minify_script_path, options, clean_lua_filepath], stdout=min_lua_file, stderr=PIPE).communicate()
    if stderrdata:
        raise Exception(f"Minify script failed with:\n\n{stderrdata.decode()}")


def inject_minified_lua_in_p8(source_file, target_file, min_lua_file):
    """
    Inject minified lua from min_lua_file (file descriptor: read)
    into a copy of source_file (file descriptor: read)
    producing target_file (file descriptor: write)

    """
    phase = Phase.CARTRIDGE_HEADER
    for line in source_file:
        if phase is Phase.CARTRIDGE_HEADER:
            # Step 4: copy header (also copy the "__lua__" line just after)
            target_file.write(line)
            if line == "__lua__\n":
                # enter lua section
                phase = Phase.LUA_SECTION

        elif phase is Phase.LUA_SECTION:
            # Step 5: copy minified lua
            target_file.writelines(min_lua_file.readlines())
            target_file.write("\n")  # newline required before other sections
            phase = Phase.LUA_CATCHUP

        elif phase is Phase.LUA_CATCHUP:
            # skip all lines until __gfx__
            if line == "__gfx__\n":
                # copy the __gfx__ line itself
                target_file.write(line)
                phase = Phase.OTHER_SECTIONS

        else:  # phase is Phase.CARTRIDGE_HEADER
            # Step 6: copy remaining sections
            target_file.write(line)


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Minify lua code in cartridge.')
    parser.add_argument('path', type=str, help='path containing cartridge file to minify')
    parser.add_argument('--minify-level', type=int, help="""define minification level,
        1: minify local variables,
        2: minify member names and table key strings,
        3: minify member names, table key strings, assigned global variables and declared global functions""")
    args = parser.parse_args()

    logging.basicConfig(level=logging.INFO)
    logging.info(f"Minifying lua code in {args.path} with minification level: {args.minify_level}...")

    minify_lua_in_p8(args.path, args.minify_level)

    logging.info(f"Minified lua code in {args.path}")
